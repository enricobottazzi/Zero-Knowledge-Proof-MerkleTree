This Repo refers to ZKU.one week1 assignment:https://zku.one/course-schedule/assignment-1-due 

Why Circom? 

Circom allows you to generate circuit to proof any matematical statement. The cherry on top of that is that it allows you to generate a smart contract that can act a verifier for the proof provided by users and program executable actions when the proof is verified! 

The real challenge of circom is to translate the matematical statement into an executable circuit! 

Q1:
Construct a circuit using circom that takes a list of numbers input as leaves of a Merkle tree (Note that the numbers will be public inputs) and outputs the Merkle root.

A1: 
- For the merkle tree hash I’ll grab the merkle tree circuit from Tornado Cash Nova: https://github.com/tornadocash/tornado-nova/blob/master/circuits/merkleTree.circom
- Write the merkleroot circuit in the file `merkletree.circom`
- Compile the circuit `circom merklertree.circom --r1cs --wasm --sym --c` 

    With these options we generate three types of files:

    --r1cs: it generates the file merkleroot.r1cs that contains the R1CS constraint system of the circuit in binary format.
    --wasm: it generates the directory merkleroot_js that contains the Wasm code (merkleroot.wasm) and other files needed to generate the witness.
    --sym : it generates the file merkleroot.sym , a symbols file required for debugging or for printing the constraint system in an annotated mode.
    --c : it generates the directory merkleroot_cpp that contains several files needed to compile the C code to generate the witness.

- Compute the witness

    Before creating the proof, we need to calculate all the signals of the circuit that match all the constraints of the circuit. For that, we will use the Wasm module generated bycircom that helps to do this job.

    We need to create a file named input.json containing the inputs written in the standard json format. 

    - Create an input.json file containing the input of my merkle tree.
    As suggested by the assignment my input will be {"leaves":[1,2,3,4]} 

    The set of inputs, intermediate signals and output is called witness.

    - To compute the witness I run 
    `node generate_witness.js merkletree.wasm input.json witness.wtns`

    - To display the witness in .json format run 
    `snarkjs wtns export json witness.wtns witness.json`
    It generates a `witness.json` file that basically display all the wires and intermediary steps computed by the circuit

- Trusted system setup 

    After compiling the circuit and running the witness calculator with an appropriate input, we will have a file with extension .wtns that contains all the computed signals and, a file with extension .r1cs that contains the constraints describing the circuit. Both files will be used to create our proof. We need a proof that tells that a set of input (leaves) generates an output (root) when put inside a merkle tree 

    We are going to use the Groth16 zk-SNARK protocol. To use this protocol, you will need to generate a trusted setup. 

    First, we start a new "powers of tau" ceremony:
    `snarkjs powersoftau new bn128 12 pot12_0000.ptau -v`
    
    Then, we contribute to the ceremony:

    `snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="First contribution" -v`

    Phase 2 (circuit specific):

    `snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v`

    Next, we generate a .zkey file that will contain the proving and verification keys together with all phase 2 contributions. Execute the following command to start a new zkey:

    `snarkjs groth16 setup merkletree.r1cs pot12_final.ptau merkletree_0000.zkey`

    Contribute to the phase 2 of the ceremony:

    `snarkjs zkey contribute merkletree_0000.zkey merkletree_0001.zkey --name="1st Contributor Name" -v`

    Export the verification key:

    `snarkjs zkey export verificationkey merkletree_0001.zkey verification_key.json`

- Generate the proof

    The setup is ready! Now we can start generating proofs!

    My goal is to proof that the 4 numbers that I passed as leaves, when put into a merkle tree, generate a merkle equal to 3330844108758711782672220159612173083623710937399719017074673646455206473965 (I grabbed this number as the second line result of witness.json)

    Once the witness is computed and the trusted setup is already executed, we can generate a zk-proof associated to the circuit and the witness:
    
    In order to generate the proof I need:

        - The proving key (merkleroot.zkey)
        - The witness ⇒ the wires executed by the circuit I generated
    
    `snarkjs groth16 prove merkletree_0001.zkey witness.wtns proof.json public.json`
    This command generates a Groth16 proof and outputs two files:

    proof.json: it contains the proof.
    public.json: it contains the values of the public inputs and outputs.

- Verifying a Proof

    `snarkjs groth16 verify verification_key.json public.json proof.json`

    If the console shows you `[INFO]  snarkJS: OK!` it means that your proof has been verified

    The counter-proof would be to create a new public.json, let's call it public_err.json, that takes in 5 as the last leaf value rather than 4.  

    If I run `snarkjs groth16 verify verification_key.json public_err.json proof.json` again, I get this error back `[ERROR] snarkJS: Invalid proof` that tells me that I got an invalid proof back

Q2: Now try to generate the proof using a list of 8 numbers. Document any errors (if any) you encounter when increasing the size and explain how you fixed them.

A2:

If I create a new input.json file `input2.json` that takes 8 leaves and I try to generate the witness 

`node generate_witness.js merkletree.wasm input2.json witness.wtns`

I get this error back `(node:13356) UnhandledPromiseRejectionWarning: Error: Error: Too many signals set. `. That's becuase I'm passing 8 leaves as input but the circom files is still configured to compile a circuit for a merkle tree of height 2 => `component main {public [leaves]} = merkle_tree(2);`

To fix it I create a new circuit (in folder Merkletree2). This is basically the same as before but it takes a different input as height of the tree (3 rather than 2)

`circom merkletree2.circom --r1cs --wasm --sym --c`

- Compute the witness with a different input.json file  

    `node generate_witness.js merkletree2.wasm input2.json witness.wtns`

- Trusted system setup (same as above)

- Generate the proof
    
    `snarkjs groth16 prove merkletree2_0001.zkey witness.wtns proof.json public.json`

- Verifying a Proof

    `snarkjs groth16 verify verification_key.json public.json proof.json`

    Yea! `[INFO]  snarkJS: OK!`. The proof has been verified!


Q3: Do we really need zero-knowledge proof for this? Can a publicly verifiable smart contract that computes Merkle root achieve the same? If so, give a scenario where Zero-Knowledge proofs like this might be useful. Are there any technologies implementing this type of proof? Elaborate in 100 words on how they work.

A3: No, we don't need ZKP for computing a merkle root starting from a set of input leaves. There are already smart contracts that can compute a merkle root starting from a set of leaves. Actually creating zero knowledge proof of the merkle tree computations requires a larger amount of computing power than using a smart contract to compute the merkle root.

The ZKP application we designed can help in making the verification system more efficient. An example of this application is at the basis of ZK-based rollups applications. Rollups include a large set of transactions inside a merkle tree. Only the root of the tree is then stored on the main-chain but any one would be able to leverage a verifier smart contract to verify that a transaction is included in the merkle tree with higher efficiency.

While creating zero knowledge proofs requires a large amount of computing power, ZK reduces computing and storage resources for validating the block by reducing the amount of data held in a transaction.